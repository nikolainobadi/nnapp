//
//  OpenTests.swift
//  nnapp
//
//  Created by Nikolai Nobadi on 3/29/25.
//

import Testing
@testable import nnapp
@preconcurrency import Files

@MainActor
final class OpenTests: MainActorTempFolderDatasource {
    private let existingGroupName = "groupName"
    private let existingProjectName = "projectName"
    private let existingCategoryName = "categoryName"
    private let existingProjectShortcut = "projectShortcut"
    private let remote: ProjectLink = .init(name: "GitHub", urlString: "github.git")
    
    init() throws {
        let testGroupFolder = TestFolder(name: existingGroupName, subFolders: [])
        let testCategoryFolder = TestFolder(name: existingCategoryName, subFolders: [testGroupFolder])
        
        try super.init(testFolder: .init(name: "openProjectCategoryList", subFolders: [testCategoryFolder]))
    }
}


// MARK: - Cannot Locate Tests
extension OpenTests {
    @Test("Throws error when can't find provided shortcut does not belong to existing Project or Group", arguments: [false, true])
    func throwsErrorWhenCannotFindProjectOrGroupWithShortcut(useGroupShortcut: Bool) {
        do {
            try runCommand(shortcut: "missingShortcut", useGroupShortcut: useGroupShortcut)
            Issue.record("expected an error to be thrown")
        } catch {
            // Expected error
        }
    }
}


// MARK: - IDE Tests
extension OpenTests {
    @Test("Throws error when selected Project folder doesn't exist and has no remote repo")
    func throwsErrorWhenSelectedProjectMissingAndNoRepo() throws {
        let factory = try makeFactory()

        do {
            try runCommand(factory, shortcut: existingProjectShortcut)
            Issue.record("expected an error to be thrown")
        } catch let launchError as CodeLaunchError {
            #expect(launchError == .noRemoteRepository)
        }
    }
    
    @Test("Throws error when selected Project folder doesn't exist and user does not want to clone")
    func throwsErrorWhenSelectedProjectMissingUserRejectsCloning() throws {
        let picker = MockPicker(shouldThrowError: true)
        let factory = try makeFactory(remote: remote, picker: picker)

        do {
            try runCommand(factory, shortcut: existingProjectShortcut)
            Issue.record("expected an error to be thrown")
        } catch {
            // Expected error
        }
    }
    
    @Test("Clones missing project")
    func clonesMissingProject() throws {
        let shell = MockShell()
        let urlString = remote.urlString
        let factory = try makeFactory(remote: remote, shell: shell)
        
        try runCommand(factory, shortcut: existingProjectShortcut)
        
        #expect(shell.printedCommands.contains(where: { $0.contains("clone \(urlString)") }))
    }
    
    @Test("Does not clone Project with remote repo when it exists locally")
    func doesNotCloneProjectThatExistsLocally() throws {
        let shell = MockShell()
        let urlString = remote.urlString
        let factory = try makeFactory(remote: remote, shell: shell)
        
        try makeProjectFolder()
        try runCommand(factory, shortcut: existingProjectShortcut)
        
        #expect(!shell.printedCommands.contains(where: { $0.contains("clone \(urlString)") }))
    }
    
    @Test("Opens new terminal window when one is not already open at Project path")
    func opensNewTerminalWindowAtProjectPath() throws {
        let shell = MockShell()
        let factory = try makeFactory(shell: shell)
        
        try makeProjectFolder()
        try runCommand(factory, shortcut: existingProjectShortcut)
        
        #expect(shell.scripts.contains(where: { $0.contains("tell application") }))
    }
    
    @Test("Does not open new terminal window when one is already open at Project path")
    func doesNotOpenTerminalWindowIfOneAlreadyIsOpen() throws {
        let projectFolder = try makeProjectFolder()
        let shell = MockShell(scriptResults: [projectFolder.path])
        let factory = try makeFactory(shell: shell)
        
        try runCommand(factory, shortcut: existingProjectShortcut)
        
        #expect(!shell.scripts.contains(where: { $0.contains("cd \(projectFolder.path)") }))
    }
    
    @Test("Opens Project file in Xcode")
    func opensProjectInXcode() throws {
        let shell = MockShell()
        let factory = try makeFactory(shell: shell)

        try makeProjectFolder()
        try runCommand(factory, shortcut: existingProjectShortcut)

        let context = try factory.makeContext()
        let project = try #require(context.loadProjects().first)
        let filePath = try #require(project.filePath)

        #expect(shell.printedCommands.contains(where: { $0.contains("open \(filePath)")}))
    }
    
    @Test("Opens project folder in VSCode")
    func opensProjectInVSCode() throws {
        let shell = MockShell()
        let factory = try makeFactory(shell: shell)

        try makeProjectFolder()
        try runCommand(factory, shortcut: existingProjectShortcut, launchType: .vscode)

        let context = try factory.makeContext()
        let project = try #require(context.loadProjects().first)
        let folderPath = try #require(project.folderPath)

        #expect(shell.printedCommands.contains(where: { $0 == "code \(folderPath)" }))
    }
}


// MARK: - Remote Tests
extension OpenTests {
    @Test("Throws error when trying to open remote repo if Project doesn't have one")
    func throwsErrorWhenOpeningRepoForProjectWithoutOne() throws {
        let factory = try makeFactory()

        do {
            try runCommand(factory, shortcut: existingProjectShortcut, launchType: .remote)
            Issue.record("expected an error to be thrown")
        } catch let launchError as CodeLaunchError {
            #expect(launchError == .missingGitRepository)
        }
    }

    @Test("Open remote repo website for Project")
    func opensRemoteRepo() throws {
        let shell = MockShell()
        let urlString = remote.urlString
        let factory = try makeFactory(remote: remote, shell: shell)
        
        try makeProjectFolder()
        try runCommand(factory, shortcut: existingProjectShortcut, launchType: .remote)

        #expect(shell.printedCommands.contains(where: { $0.contains("open \(urlString)") }))
    }

}


// MARK: - OtherLink Tests
extension OpenTests {
    @Test("Throws error when trying to open ProjectLink for Project without any links")
    func throwsErrorWhenOpeningLinkForProjectWithoutLinks() throws {
        let factory = try makeFactory()

        do {
            try runCommand(factory, shortcut: existingProjectShortcut, launchType: .link)
            Issue.record("expected an error to be thrown")
        } catch let launchError as CodeLaunchError {
            #expect(launchError == .missingProjectLink)
        }
    }

    @Test("Opens ProjectLink for Project")
    func opensProjectLink() throws {
        let shell = MockShell()
        let link = ProjectLink(name: "Docs", urlString: "https://docs.example.com")
        let factory = try makeFactory(projectLinks: [link], shell: shell)
        
        try runCommand(factory, shortcut: existingProjectShortcut, launchType: .link)

        #expect(shell.printedCommands.contains(where: { $0.contains("open \(link.urlString)") }))
    }
}


// MARK: - Factory
private extension OpenTests {
    @discardableResult
    func makeProjectFolder() throws -> Folder {
        let categoryFolder = try tempFolder.subfolder(named: existingCategoryName)
        let groupFolder = try categoryFolder.subfolder(named: existingGroupName)

        return try groupFolder.createSubfolder(named: existingProjectName)
    }
    
    func makeFactory(remote: ProjectLink? = nil, projectLinks: [ProjectLink] = [], shell: MockShell = .init(), picker: MockPicker = .init()) throws -> MockContextFactory {
        let factory = MockContextFactory(shell: shell, picker: picker)
        let context = try factory.makeContext()
        let existingCategoryFolder = try tempFolder.subfolder(named: existingCategoryName)
        let category = makeCategory(name: existingCategoryName, path: existingCategoryFolder.path)
        let group = makeGroup(name: existingGroupName)
        let project = makeProject(name: existingProjectName, shortcut: existingProjectShortcut, remote: remote, links: projectLinks)

        try context.saveCategory(category)
        try context.saveGroup(group, in: category)
        try context.saveProject(project, in: group)

        return factory
    }
}


// MARK: - RunCommand
private extension OpenTests {
    func runCommand(_ factory: MockContextFactory? = nil, shortcut: String? = nil, launchType: LaunchType = .xcode, useGroupShortcut: Bool = false) throws {
        var args = ["open", "-\(launchType.argChar)"]
        
        if useGroupShortcut {
            args.append("-g")
        }
        
        if let shortcut {
            args.append(shortcut)
        }
        
        try Nnapp.testRun(contextFactory: factory, args: args)
    }
}
